# Milestone 4.9 – Proposal 2  
**Keep StateDB entirely in Rust and expose snapshot handle**

## Motivation
Batch-prefetch eliminated ~99 % of CGO look-ups, but every remaining miss (and every commit) still crosses the Go↔Rust boundary. Moving full StateDB management into Rust removes those hops, enables cheap snapshots (copy-on-write layers) and opens doors for advanced caching strategies.

## High-level goals
1. Eliminate per-slot/account CGO calls during block execution.
2. Provide cheap `snapshot → execute → commit` cycle for each transaction.
3. Preserve existing Go `stateDB` as the single source of truth after commit.
4. Maintain identical consensus hashes (state root, receipts, logs).

## Design sketch
### Rust side
* `type RustDB = CacheDB<GoDatabase>` – current per-block DB.
* `RustDB::nest()` ⇒ `CacheDB<RustDB>` gives copy-on-write layer (zero-copy for untouched data).
* `struct RustSnapshot { evm: MainnetEvm<Context<…, RustDBNested>>, … }`.
* C API exports
  * `revm_snapshot_clone(parent) -> *mut RustSnapshot`  ✔ Phase-1 stub (deep-clone)
  * `revm_snapshot_free(ptr)`  ✔ existing (`revm_free_statedb_instance`)
  * `revm_snapshot_commit(ptr)` – flatten into parent (Phase-3)

### Go side (`revm_bridge`)
```
root := revm.NewStateDB(handle)           // block-level DB
for _, tx := range block.Transactions() {
    snap := root.SnapshotClone()
    res  := revm.ExecuteTx(snap, tx)
    if res.Success {
        snap.Commit()                    // merge into root
    } else {
        snap.Free()                      // discard
    }
}
root.CommitToGoStateDB()
```

### Diff export
Use `CacheDB::flatten()` to obtain changed accounts/storage, convert to Go `stateDB.Set*` calls in bulk.

## Implementation phases
| Phase | Scope | Expected time |
|-------|-------|---------------|
| 1. Plumbing  ✔ | FFI functions for snapshot clone/free. Stub clone by `Clone`. Tests stay green. | 0.5–1 d |
| 2. Integration | Replace per-tx `evm.New()` in Go with `SnapshotClone()`. Measure miss counters → should drop to 0. | 1–2 d |
| 3. Commit diff | Implement `snapshot_commit` in Rust; bulk-export modified accounts to Go. Verify state-root parity. | 1–2 d |
| 4. Optimise | Switch clone to `CacheDB::nest()` (true COW), add metrics & leak-checks. | 0.5 d |

## Risks & mitigation
* **Memory leaks** – enforce `defer Free()` and add Rust ref-count asserts.
* **Root divergence** – keep parity tests in CI.
* **Large diff marshal** – can compress/arena in later iterations.

---
*Last updated: <2025-06-24>* 